import { JSDoc, Project, SourceFile, SyntaxKind, TypeAliasDeclaration } from 'ts-morph';

export interface CompilerOptions {
  project: Project;
  outputFilePath: string;
}

export class WhereFilterCompiler {
  private readonly project: Project;
  private readonly outputFilePath: string;

  constructor(options: CompilerOptions) {
    this.project = options.project;
    this.outputFilePath = options.outputFilePath;
  }

  public compile() {
    const taggedTypeAliases = this.findTaggedTypeAliases();
    if (taggedTypeAliases.length === 0) {
      console.log('No types with a "@precompile-filter" tag found.');
      return;
    }

    const tempSourceFile = this.project.createSourceFile(
      '__temp_filter_types__.ts',
      '',
      { overwrite: true }
    );

    // This setup is perfect: import all dependencies into the temporary file.
    const declarationFile = this.project.getSourceFileOrThrow(
      (sf) => sf.getFilePath().endsWith('index-where-filter-type.d.ts')
    );
    tempSourceFile.addImportDeclaration({
      moduleSpecifier: tempSourceFile.getRelativePathAsModuleSpecifierTo(declarationFile),
      isTypeOnly: true,
      namedImports: ['WhereFilterDefinition'],
    });

    for (const typeAlias of taggedTypeAliases) {
      const originalTypeName = typeAlias.getName();
      const filterTypeName = `${originalTypeName}Filter`;

      const originalTypeSourceFile = typeAlias.getSourceFile();
      tempSourceFile.addImportDeclaration({
        moduleSpecifier: tempSourceFile.getRelativePathAsModuleSpecifierTo(originalTypeSourceFile),
        namedImports: [originalTypeName],
      });

      tempSourceFile.addTypeAlias({
        name: filterTypeName,
        isExported: true,
        type: `WhereFilterDefinition<${originalTypeName}>`,
      });
    }

    // --- FINAL STRATEGY: Get Declaration Text Directly from Emit Result ---

    // 1. Get the declaration output for ONLY our temporary file.
    // This is more direct than a full project `emit()`.
    const emitResult = tempSourceFile.getEmitOutput({ emitOnlyDtsFiles: true });
    
    const diagnostics = emitResult.getDiagnostics();
    if (diagnostics.length > 0) {
        console.error(this.project.formatDiagnosticsWithColorAndContext(diagnostics));
        throw new Error('Encountered errors during declaration file generation.');
    }

    // 2. The result contains the output files. We expect exactly one.
    const outputFiles = emitResult.getOutputFiles();
    if (outputFiles.length === 0) {
        throw new Error('Compiler did not emit a declaration file as expected.');
    }

    // 3. The emitted text IS our fully resolved type.
    const emittedText = outputFiles[0]!.getText();

    // 4. Create the final output file with the resolved type definitions.
    // We can add a header for context.
    const fileHeader = `/**\n * This file is pre-compiled and should not be edited directly.\n * Generated by the where-filter-compiler.\n */\n\n`;
    this.project.createSourceFile(this.outputFilePath, fileHeader + emittedText, {
      overwrite: true,
    });
    
    console.log(`Successfully compiled filter types to ${this.outputFilePath}`);
    
    // It's good practice to clean up the temporary file from the project object.
    this.project.removeSourceFile(tempSourceFile);
  }

  private findTaggedTypeAliases(): TypeAliasDeclaration[] {
    const sourceFiles = this.project.getSourceFiles();
    const taggedTypeAliases: TypeAliasDeclaration[] = [];

    for (const sourceFile of sourceFiles) {
      if (sourceFile.isDeclarationFile() || sourceFile.getBaseName().startsWith('__temp')) {
        continue;
      }
      const typeAliases = sourceFile.getDescendantsOfKind(SyntaxKind.TypeAliasDeclaration);
      for (const typeAlias of typeAliases) {
        if (this.hasPrecompileFilterTag(typeAlias.getJsDocs())) {
          taggedTypeAliases.push(typeAlias);
        }
      }
    }
    return taggedTypeAliases;
  }

  private hasPrecompileFilterTag(jsDocs: JSDoc[]): boolean {
    return jsDocs.some(doc =>
      doc.getTags().some(tag => tag.getTagName() === 'precompile-filter')
    );
  }
}