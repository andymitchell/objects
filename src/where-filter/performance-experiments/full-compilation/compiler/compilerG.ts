import { JSDoc, Project, SourceFile, SyntaxKind, TypeAliasDeclaration } from 'ts-morph';

export interface CompilerOptions {
  project: Project;
  outputFilePath: string;
}

export class WhereFilterCompiler {
  private readonly project: Project;
  private readonly outputFilePath: string;

  constructor(options: CompilerOptions) {
    this.project = options.project;
    this.outputFilePath = options.outputFilePath;
  }

  public compile() {
    const taggedTypeAliases = this.findTaggedTypeAliases();
    if (taggedTypeAliases.length === 0) {
      console.log('No types with a "@precompile-filter" tag found.');
      return;
    }

    const tempSourceFile = this.project.createSourceFile(
      '__temp_filter_types__.ts',
      '',
      { overwrite: true }
    );

    // This setup of importing dependencies into a temporary file is correct.
    const declarationFile = this.project.getSourceFileOrThrow(
      (sf) => sf.getFilePath().endsWith('index-where-filter-type.d.ts')
    );
    tempSourceFile.addImportDeclaration({
      moduleSpecifier: tempSourceFile.getRelativePathAsModuleSpecifierTo(declarationFile),
      isTypeOnly: true,
      namedImports: ['WhereFilterDefinition'],
    });

    for (const typeAlias of taggedTypeAliases) {
      const originalTypeName = typeAlias.getName();
      const filterTypeName = `${originalTypeName}Filter`;

      const originalTypeSourceFile = typeAlias.getSourceFile();
      tempSourceFile.addImportDeclaration({
        moduleSpecifier: tempSourceFile.getRelativePathAsModuleSpecifierTo(originalTypeSourceFile),
        namedImports: [originalTypeName],
      });

      tempSourceFile.addTypeAlias({
        name: filterTypeName,
        isExported: true,
        type: `WhereFilterDefinition<${originalTypeName}>`,
      });
    }

    // --- THE FIX ---
    // We MUST enable declaration file generation in the project's compiler options.
    // The emitter will not produce .d.ts files if this is not set to true.
    this.project.compilerOptions.set({ declaration: true });
    // ---------------

    // Now, get the declaration output for our specific temporary file.
    const emitResult = tempSourceFile.getEmitOutput({ emitOnlyDtsFiles: true });
    
    const diagnostics = emitResult.getDiagnostics();
    if (diagnostics.length > 0) {
        console.error(this.project.formatDiagnosticsWithColorAndContext(diagnostics));
        throw new Error('Encountered errors during declaration file generation.');
    }

    const outputFiles = emitResult.getOutputFiles();
    if (outputFiles.length === 0) {
        // This error should no longer be triggered.
        throw new Error('Compiler did not emit a declaration file as expected.');
    }

    const emittedText = outputFiles[0]!.getText();

    const fileHeader = `/**\n * This file is pre-compiled and should not be edited directly.\n * Generated by the where-filter-compiler.\n */\n\n`;
    this.project.createSourceFile(this.outputFilePath, fileHeader + emittedText, {
      overwrite: true,
    }).saveSync(); // Save the final output.
    
    console.log(`Successfully compiled filter types to ${this.outputFilePath}`);
    
    // Clean up the temporary file.
    this.project.removeSourceFile(tempSourceFile);
  }

  private findTaggedTypeAliases(): TypeAliasDeclaration[] {
    const sourceFiles = this.project.getSourceFiles();
    const taggedTypeAliases: TypeAliasDeclaration[] = [];

    for (const sourceFile of sourceFiles) {
      if (sourceFile.isDeclarationFile() || sourceFile.getBaseName().startsWith('__temp')) {
        continue;
      }
      const typeAliases = sourceFile.getDescendantsOfKind(SyntaxKind.TypeAliasDeclaration);
      for (const typeAlias of typeAliases) {
        if (this.hasPrecompileFilterTag(typeAlias.getJsDocs())) {
          taggedTypeAliases.push(typeAlias);
        }
      }
    }
    return taggedTypeAliases;
  }

  private hasPrecompileFilterTag(jsDocs: JSDoc[]): boolean {
    return jsDocs.some(doc =>
      doc.getTags().some(tag => tag.getTagName() === 'precompile-filter')
    );
  }
}